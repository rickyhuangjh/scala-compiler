/*
   Copyright 2024 Ondrej Lhotak. All rights reserved.

   Permission is granted for private study use by students registered in
   CS 241E in the Fall 2024 term.

   The contents of this file may not be published, in whole or in part,
   in print or electronic form.

   The contents of this file may be included in work submitted for CS
   241E assignments in Fall 2024. The contents of this file may not be
   submitted, in whole or in part, for credit in any other course.
*/
package cs241e.assignments

import cs241e.scanparse.*
import Grammars.*
import DFAs.*

import scala.collection.mutable

/** Parsers for general grammars. */

object Parsing {
    /** Parses the `input` sequence of `Token`s according to the `grammar` using the Cocke-Younger-Kasami algorithm.
     * Specifically, the `kind`s of the `Token`s are considered as the terminals of the grammar, and the
     * `lexeme`s are not used for parsing but are preserved in the resulting parse tree.
     *
     * If the parse is ambiguous, returns an arbitrary one of the possible parse trees.
     *
     * If the `input` is not in the language generated by the grammar, returns `None`.
     */
    def parseCYK(grammar: Grammar, input: IndexedSeq[Token]): Option[Tree] = {
        /** The memoization table: if the string of symbols ABC derives the substring of length `length`
         * starting at position `from` of the `input`, then the entry for (Seq("A", "B", "C"), from, length)
         * contains the three parse trees of A, B, and C. If a particular string of symbols
         * does not derive a given substring of the `input`, the corresponding table entry is `None`.
         */
        val memo = mutable.Map[(Seq[String], Int, Int), Option[Seq[Tree]]]()


        /** If the string of symbols `lhs` derives the substring of length `length`
         * starting at position `from` of the `input`, returns a sequence of the parse trees for the
         * symbols in `lhs`.
         *
         * If `lhs` does not derive this substring of the input, returns `None`.
         */

        def recur(lhs: List[String], from: Int, length: Int): Option[Seq[Tree]] = {
            // println(s"start ${lhs}, ${from} ${length} ${input.slice(from, from+length)}")


            if (memo.contains((lhs, from, length))) {
                // println(s"infinite loop return ${lhs}")
                return memo((lhs, from, length))
            }
            // if (lhs.nonEmpty) println(lhs.head + " " + input(from) + length)
            memo((lhs, from, length)) = None
            if (lhs.isEmpty) {
                // Case 1
                if (length == 0) {
                    memo((lhs, from, length)) = Some(Seq.empty)
                }
            }
            else if (grammar.terminals.contains(lhs.head)) {
                // Case 2

                 memo((lhs, from, length)) =
                     if (length > 0 && input(from).kind == lhs.head) {
                         recur(lhs.tail, from + 1, length - 1) match
                             case Some(trees) => {
                                 Some(Tree(input(from)) +: trees)
                             }
                             case None => None
                     } else None
            } else if (grammar.nonTerminals.contains(lhs.head) && lhs.length == 1) {
                // Case 3
                // println(lhs.head ++ Seq(" ") ++ input(from).kind ++ Seq("case 3"))
                for (production <- grammar.productions if production.lhs == lhs.head) {
                    recur(production.rhs.toList, from, length) match
                        case Some(trees) =>
                            memo((lhs, from, length)) = Some(Seq(Tree(Token(lhs.head), trees)))
                        case None => None
                }
            } else {
                // println(lhs.head ++ Seq(" ") ++ input(from).kind ++ Seq("case 4"))
                for (leftLength <- 0 to length) {
                    // println(s"recursing case 4 ${lhs.head}, ${input.slice(from, from+leftLength)}")
                    (recur(List(lhs.head), from, leftLength),
                        recur(lhs.tail, from + leftLength, length - leftLength)) match
                        case (Some(leftTrees), Some(rightTrees)) =>
                            memo((lhs, from, length)) =
                                Some(leftTrees ++ rightTrees)
                        case _ => None
                }
            }
            // Case 4
            // if (memo((lhs, from, length)).isDefined) println(s"ok ${lhs.head},${input(from)}")
            // else println(s"bad ${lhs.head}, ${input(from)}")
            val res = memo((lhs, from, length))
            // println(res)
            res
        }
        
        val r = recur(List(grammar.start), 0, input.size).map(_.head)
        // println(memo(List("BOF", "defdefs", "EOF"), 0, input.length))
        r
    }

    /** Parses the `input` string of terminals according to the `grammar` using Earley's algorithm.
     * Returns `true` if the `input` string is in the language generated by the `grammar`,
     * `false` otherwise.
     *
     * Note: Optional, for bonus only.
     */
    def parseEarley(grammar: Grammar, input: IndexedSeq[String]): Boolean = { ??? }
}
